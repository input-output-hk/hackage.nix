{ system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }:
  {
    flags = {};
    package = {
      specVersion = "1.2";
      identifier = { name = "reorderable"; version = "0.3.1"; };
      license = "LicenseRef-OtherLicense";
      copyright = "(c) 2013, Alex Cole";
      maintainer = "Alex Cole <haskell@y-less.com>";
      author = "Alex Cole <haskell@y-less.com>";
      homepage = "";
      url = "";
      synopsis = "Define compound types that do not depend on member order.";
      description = "\n* Introduction.\n\nThe pair `(Int, Float)' is entirely distinct from the pair `(Float, Int)'\nand trying to use one in place of the other will give a type error.\nThis is often, but not always, desired.\n\n* Module.\n\nThis module provides more flexible sum and product types that do not enforce\na single order on their elements.  This does introduce some necessary\nrestrictions, for example only one instance of any type can appear in\nany given collection of types.  Additionally, all types that are to be\nused in one of these flexible containers must be pre-defined as\n`reorderable':\n\n@\ndata MyType1 = MyType1 Int\ndata MyType2 = MyType2 Float\ndata MyType3 = MyType3 Bool\ndata MyType3 = MyType4 String\nreorderable ''MyType1\nreorderable ''MyType2\nreorderable ''MyType3\nreorderable ''MyType4\n@\n\nThat will, using /Template Haskell/, generate all the required instances to\nmake those types usable as reorderable types within unordered\ncontainers.  Following that, all the declarations below are valid:\n\n@\ntype Reordered1A = ReorderableEnd :*: MyType2 :*: MyType1\ntype Reordered1B = ReorderableEnd :*: MyType1 :*: MyType2\ntype Reordered2  = Reordered1A    :*: MyType3\ntype Reordered3  = ReorderableEnd :*: MyType4 :*: Reordered1B\n@\n\nTypes `Reordered1A' and `Reordered1B' are in fact now identical.  This does\nintroduce a third limitation of the library I have been unable to lift -\nthe use of `ReorderableEnd' as a sentinel in all reorderable containers.\n\nIt may be the case that `Type1' and `Type2' can be used together, as can\n`Type3' and `Type4', but the two sets of types can not be used in a\ncontainer together.  These are /groups/ of types:\n\n@\nreorderableGroup [''MyType1, ''MyType2]\nreorderableGroup [''MyType3, ''MyType4]\n@\n\nThe groups can overlap:\n\n@\nreorderableGroup [''MyType1, ''MyType2]\nreorderableGroup [''MyType1, ''MyType3, ''MyType4]\n@\n\nBut this may cause some \\\"leakage\\\" where types from two different groups\n(for example `MyType2' and `MyType4') end up in the same container,\nattached via common types.\n\n* Generation.\n\nFor each type `X' for which `reorderable' (or equivalent) is called, the\nfollowing functions are generated (where `X' is the type name):\n\n@\naddSumX :: (x :>: s) => s -> s :+: x\nsetSumX :: (x :<: s) => x -> s -> s\ngetSumX :: (x :<: s) => s -> Maybe x\naddProductX :: (x :~: s) => x -> s -> s :*: x\nsetProductX :: (x :?: s) => x -> s -> s\ngetProductX :: (x :?: s) => s -> x\nremoveProductX :: (x :?: s) => s -> s :-: x\n@\n\n** Notes on the syntax:\n\n* `:<:' Is read as \\\"Is member of sum type\\\".\n* `:>:' Is read as \\\"Is not member of sum type\\\".\n* `:+:' Is read as \\\"Plus\\\".\n* `:?:' Is read as \\\"Is member of product type\\\".\n* `:~:' Is read as \\\"Is not member of product type\\\".\n* `:*:' Is read as \\\"Product\\\".\n* `:-:' Is read as \\\"Remove\\\".\n\n** Notes on the functions:\n\n* `addSumX' Adds the TYPE `x' to the given signature, and correctly\nre-wraps the contained data to reflect this new structure.  It does\nnot add any data in to the structure itself because only one item\nmay exist in the structure, and that item is already there.\n\n* `setSumX' Changes what data is currently stored in the sum.  For a\ngiven concrete sum type `S', this can be called as:\n`setSumX x (undefined :: S)'.  An alternative version is simply:\n`setSumType (undefined :: S) x', in which `X :<: S'.  This is\nequivalent to the original `inj' function from `Data Types \\'a la\nCarte', but has an explicit type proxy.\n\n* `getSumX' Returns the data of type `Just X' IF it is the data\ncurrently being stored within the sum, otherwise it returns\n`Nothing'.  This is equivalent to the original `prj' function from\n`Data Types \\'a la Carte'.\n\n* `addProductX' Adds data of type `X' to an existing product type that\ndoes not yet contain any data of that type.\n\n* `setProductX' Sets the data of type `X' in a product type that already\ncontains data of that type.\n\n* `getProductX' Gets the data of type `X' from a product type that\ncontains data of that type.\n\n* `removeProductX' Removes data of type `X' from a product type that\ncontains data of that type, and rewraps the resulting information to\nremove `X' from the product's type.  There is no `removeSumX'\nfunction because the result is empty if the stored data is not of\nthe type being removed.\n\n* Generators.\n\nIn addition to being able to control for which types code is generated, you\ncan control what code is generated for them through `reorderer's.  Note\nthat the default code listed above is ALWAYS generated, you can\ncurrently only ADD to the generation code.  The simplest way to explain\nthis is through an example:\n\n@\nclass ReorderableSum a\n[reorderer|ReorderableSum\naddSum??? :: (OutSumType without ???) => without -> AddSumType without ???\naddSum??? without = addSumType without (undefined :: ???)\nsetSum??? :: (InSumType with ???) => ??? -> with -> with\nsetSum??? a b = setSumType b a\ngetSum??? :: (InSumType with ???) => with -> Maybe ???\ngetSum??? with = getSumType with (undefined :: ???)\n|]\n@\n\nThe code above is exactly the code used to generate the sum type functions\ndocumented above.  The internal class names are used in place of the\ntype operator synonyms for simplicity.  `???' is used as a placeholder\nto be replaced by the unqualified type names from every instance of\n`reorderable' in the code.  The empty class `ReorderableSum' is a\nunique name with a single type parameter, passed as the first symbol\nto the reorderer.  An instance of this class is generated for each\nreorderable type, to track for which types this reorderer has already\nbeen generated (using `reify').  The simple reason for this is that\nplacing the same type in two `reorderableGroup's will, without that\ncheck, attempt to instantiate this code twice and thus give errors.\n\nWhat can be done within generators is very constrained.  For one thing, the\nparameter `a' to `ReorderableSum' currently MUST have kind `*', so any\nreorderable types may not have type parameters themselves (unless a new\ngenerator is written for exactly that type).  Additionally, the\nplaceholder `???' in no way accounts for complex names - it is purely a\ntext-based replacement, so trying to create a reorderable ``Maybe Int''\ntype will result in the illegal:\n\n@\naddSumMaybe Int :: ...\n@\n\nFinally, this code is processed with \\\"haskell-src-meta\\\", and so any code\nmust be parsable with that code.  One lifting of this restriction is\nthat reorderers may additionally contain type family declarations, which\nare by default not supported by that library (despite having issued a\npull request many months ago).";
      buildType = "Simple";
      };
    components = {
      "library" = {
        depends = [
          (hsPkgs.base)
          (hsPkgs.template-haskell)
          (hsPkgs.haskell-src-meta)
          (hsPkgs.haskell-src-exts)
          (hsPkgs.constraints)
          ];
        };
      };
    }