{ system
  , compiler
  , flags
  , pkgs
  , hsPkgs
  , pkgconfPkgs
  , errorHandler
  , config
  , ... }:
  {
    flags = {};
    package = {
      specVersion = "1.12";
      identifier = { name = "lapack-comfort-array"; version = "0.0.1.1"; };
      license = "BSD-3-Clause";
      copyright = "";
      maintainer = "Henning Thielemann <haskell@henning-thielemann.de>";
      author = "Henning Thielemann <haskell@henning-thielemann.de>";
      homepage = "https://hub.darcs.net/thielema/lapack-comfort-array/";
      url = "";
      synopsis = "Auto-generated interface to Fortran LAPACK via comfort-array";
      description = "LAPACK is a package for efficient numerically robust linear algebra.\nThe original implementation is written in FORTRAN.\nThis is a semi-automatically generated mid-level wrapper.\nThe functions are not ready to use for high-level applications,\nbut they are a step closer.\n\nThe functions are all in IO monad because they are auto-generated and\nwe cannot make sure automatically that unsafePerformIO is always safe.\nInstead of raw pointers we use Arrays and Mutable.Arrays\nand assign and check array bounds to LAPACK function parameters,\nas far we can retrieve this information from the FORTRAN comments.\nWe check consistency of dimensions where consistent dimensions are required,\nbut we cannot do all kind of bound checks.\nWe use immutable Array for input and output parameters\nand mutable Mutable.Array for input/output parameters.\nLAPACK plays some nasty tricks of in-place array updates\non input/output arrays\neven if the dimensions of input and output array differ (see e.g. GELS).\nThe wrappers also manage allocation of memory for function parameters.\nThis is necessary since FORTRAN passes all parameters by reference.\nFurther on, the wrappers convert from Haskell values like @Int@\nto low-level values like @CInt@.\n\nWe provide bindings to functions of all variants\nfor @Float@, @Double@, @Complex Float@ and @Complex Double@.\nWe do not use TemplateHaskell nor HSC nor CHS, but instead Haskell 98 code\ngenerated by the custom @lapack-ffi-tools@ package.";
      buildType = "Simple";
    };
    components = {
      "library" = {
        depends = [
          (hsPkgs."lapack-ffi" or (errorHandler.buildDepError "lapack-ffi"))
          (hsPkgs."netlib-comfort-array" or (errorHandler.buildDepError "netlib-comfort-array"))
          (hsPkgs."netlib-ffi" or (errorHandler.buildDepError "netlib-ffi"))
          (hsPkgs."comfort-array" or (errorHandler.buildDepError "comfort-array"))
          (hsPkgs."storable-complex" or (errorHandler.buildDepError "storable-complex"))
          (hsPkgs."transformers" or (errorHandler.buildDepError "transformers"))
          (hsPkgs."base" or (errorHandler.buildDepError "base"))
        ];
        buildable = true;
      };
    };
  }