{ system
  , compiler
  , flags
  , pkgs
  , hsPkgs
  , pkgconfPkgs
  , errorHandler
  , config
  , ... }:
  {
    flags = {};
    package = {
      specVersion = "3.0";
      identifier = { name = "trexio-hs"; version = "0.2.0"; };
      license = "BSD-3-Clause";
      copyright = "";
      maintainer = "phillip.seeber@uni-jena.de";
      author = "Phillip Seeber";
      homepage = "https://github.com/TREX-CoE/trexio-hs";
      url = "";
      synopsis = "Bindings to the TREXIO library for wave function data";
      description = "This package provides low- and high-level Haskell bindings for [TREXIO, a portable file format for storing wave function data](https://trex-coe.github.io/trexio/).\nTested with TREXIO versions:\n\n  * 2.5.0\n  * 2.6.0\n\nThe vast majority of the bindings in this package is generated via TemplateHaskell from the TREXIO JSON specification, that then defines the C-API.\nFor more details see the [TREXIO documentation](https://trex-coe.github.io/trexio/lib.html).\nConsequently, this package is able to adapt to changes in the TREXIO specification, but the Hackage version reflects the canonical upstream TREXIO specification.\n\nThe low-level API is a direct mapping of the C-API, with minimal abstraction, i.e. passing raw pointers around and responsibility for memory management is on the user.\nSee the @TREXIO.LowLevel@ module for more details.\nThe @TREXIO.LowLevel.Scheme@ module is the Aeson representation of the TREXIO JSON specification and reflects the structure that was used by TemplateHaskell for code generation.\nHowever, the low-level bindings are very complete and allow for buffered IO of large quantities such as the Electron Repulsion Integrals or Configuration State Functions.\n\nThe high-level API is more haskellish and provides a more type-safe and user-friendly interface to the TREXIO library.\nThe @TREXIO@ module provides your entry point to the high-level API.\nFunction names are automatically generated by stripping the @trexio_@ prefix from the C-API and converting to camel case.\nFurthermore, @TREXIO.HighLevel.Records@ provides a direct translation of the TREXIO JSON specification to Haskell records (without buffered IO, however).\nThe @TREXIO.HighLevel.Records@ is not used for any other purpose within this library, however.\n\nThe high-level API utilises @TREXIO.CooArray@ to provide a more idiomatic interface to sparse arrays used for many high-dimensional quantities within TREXIO.\n\nThese bindings heavily rely on [Massiv](https://hackage.haskell.org/package/massiv) for handling arrays.\n\nExample usage:\n\n@\nimport TREXIO\nimport TREXIO.CooArray\nimport Data.Massiv.Array as Massiv\n\nmain :: IO ()\nmain = do\n    \\-- Get the version of TREXIO we have linked against\n    ver <- version\n    putStrLn $ \"TREXIO version: \" <> ver\n\n    withTrexio \"example.h5\" FileWrite Hdf5 $ \\\\trexio -> do\n        \\-- Write nuclear coordinates to a TREXIO file\n        coords <- Massiv.fromListsM Par\n            [ [0. , 0., -0.24962655]\n            , [0. , 2.70519714, 1.85136466]\n            , [0. , -2.70519714, 1.85136466]\n            ]\n        writeNucleusCoord trexio coords\n\n        \\-- Read reduced 2-electron density matrix (assuming it exists in the example.h5)\n        rdm2e <- readRdm2e trexio\n        print rdm2e\n@";
      buildType = "Simple";
    };
    components = {
      "library" = {
        depends = [
          (hsPkgs."aeson" or (errorHandler.buildDepError "aeson"))
          (hsPkgs."base" or (errorHandler.buildDepError "base"))
          (hsPkgs."bitvec" or (errorHandler.buildDepError "bitvec"))
          (hsPkgs."bytestring" or (errorHandler.buildDepError "bytestring"))
          (hsPkgs."casing" or (errorHandler.buildDepError "casing"))
          (hsPkgs."containers" or (errorHandler.buildDepError "containers"))
          (hsPkgs."filepath" or (errorHandler.buildDepError "filepath"))
          (hsPkgs."massiv" or (errorHandler.buildDepError "massiv"))
          (hsPkgs."safe-exceptions" or (errorHandler.buildDepError "safe-exceptions"))
          (hsPkgs."template-haskell" or (errorHandler.buildDepError "template-haskell"))
          (hsPkgs."temporary" or (errorHandler.buildDepError "temporary"))
          (hsPkgs."typed-process" or (errorHandler.buildDepError "typed-process"))
          (hsPkgs."text" or (errorHandler.buildDepError "text"))
          (hsPkgs."vector" or (errorHandler.buildDepError "vector"))
          (hsPkgs."trexio-hs".components.sublibs.trexio-internal or (errorHandler.buildDepError "trexio-hs:trexio-internal"))
        ];
        libs = [ (pkgs."trexio" or (errorHandler.sysDepError "trexio")) ];
        buildable = true;
      };
      sublibs = {
        "trexio-internal" = {
          depends = [
            (hsPkgs."aeson" or (errorHandler.buildDepError "aeson"))
            (hsPkgs."base" or (errorHandler.buildDepError "base"))
            (hsPkgs."bitvec" or (errorHandler.buildDepError "bitvec"))
            (hsPkgs."bytestring" or (errorHandler.buildDepError "bytestring"))
            (hsPkgs."casing" or (errorHandler.buildDepError "casing"))
            (hsPkgs."containers" or (errorHandler.buildDepError "containers"))
            (hsPkgs."filepath" or (errorHandler.buildDepError "filepath"))
            (hsPkgs."massiv" or (errorHandler.buildDepError "massiv"))
            (hsPkgs."safe-exceptions" or (errorHandler.buildDepError "safe-exceptions"))
            (hsPkgs."template-haskell" or (errorHandler.buildDepError "template-haskell"))
            (hsPkgs."temporary" or (errorHandler.buildDepError "temporary"))
            (hsPkgs."typed-process" or (errorHandler.buildDepError "typed-process"))
            (hsPkgs."text" or (errorHandler.buildDepError "text"))
            (hsPkgs."vector" or (errorHandler.buildDepError "vector"))
          ];
          libs = [ (pkgs."trexio" or (errorHandler.sysDepError "trexio")) ];
          buildable = true;
        };
      };
      tests = {
        "trexio-test" = {
          depends = [
            (hsPkgs."aeson" or (errorHandler.buildDepError "aeson"))
            (hsPkgs."base" or (errorHandler.buildDepError "base"))
            (hsPkgs."bitvec" or (errorHandler.buildDepError "bitvec"))
            (hsPkgs."bytestring" or (errorHandler.buildDepError "bytestring"))
            (hsPkgs."casing" or (errorHandler.buildDepError "casing"))
            (hsPkgs."containers" or (errorHandler.buildDepError "containers"))
            (hsPkgs."filepath" or (errorHandler.buildDepError "filepath"))
            (hsPkgs."massiv" or (errorHandler.buildDepError "massiv"))
            (hsPkgs."safe-exceptions" or (errorHandler.buildDepError "safe-exceptions"))
            (hsPkgs."template-haskell" or (errorHandler.buildDepError "template-haskell"))
            (hsPkgs."temporary" or (errorHandler.buildDepError "temporary"))
            (hsPkgs."typed-process" or (errorHandler.buildDepError "typed-process"))
            (hsPkgs."text" or (errorHandler.buildDepError "text"))
            (hsPkgs."vector" or (errorHandler.buildDepError "vector"))
            (hsPkgs."trexio-hs" or (errorHandler.buildDepError "trexio-hs"))
            (hsPkgs."directory" or (errorHandler.buildDepError "directory"))
            (hsPkgs."tasty" or (errorHandler.buildDepError "tasty"))
            (hsPkgs."tasty-hunit" or (errorHandler.buildDepError "tasty-hunit"))
            (hsPkgs."tasty-hedgehog" or (errorHandler.buildDepError "tasty-hedgehog"))
            (hsPkgs."hedgehog" or (errorHandler.buildDepError "hedgehog"))
          ];
          buildable = true;
        };
      };
    };
  }