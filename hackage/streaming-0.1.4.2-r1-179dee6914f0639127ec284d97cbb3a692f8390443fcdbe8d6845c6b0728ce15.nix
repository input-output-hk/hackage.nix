{ system
, compiler
, flags
, pkgs
, hsPkgs
, pkgconfPkgs
, ... }:
  {
    flags = {};
    package = {
      specVersion = "1.10";
      identifier = {
        name = "streaming";
        version = "0.1.4.2";
      };
      license = "BSD-3-Clause";
      copyright = "";
      maintainer = "what_is_it_to_do_anything@yahoo.com";
      author = "michaelt";
      homepage = "https://github.com/michaelt/streaming";
      url = "";
      synopsis = "an elementary streaming prelude and general stream type.";
      description = "@Streaming.Prelude@ exports an elementary streaming prelude focused on\na simple \\\"source\\\" or \\\"producer\\\" type, namely @Stream (Of a) m r@.\n@Stream (Of a) m r@ is a sort of effectful version of\n@([a],r)@ in which successive elements arise from some sort of monadic\naction. Everything is the library is organized to make\nprogramming with this type as simple as possible\nby making it as close to @Prelude@ and @Data.List@. Thus for example\nthe trivial program\n\n> S.sum (S.take 3 (S.readLn :: Stream (Of Int) IO ()))\n\nsums the first three valid integers from user input. Similarly,\n\n> S.stdoutLn (S.map reverse (S.take 3 S.stdinLn))\n\nreverses the first three lines from stdin as they arise,\nand sends them to stdout. And so on,\nwith filtering, mapping, breaking, chunking and so forth.\nWe program with streams of @Int@s or @String@s directly as\nif they constituted something like a list rather than \\\"extracting a list from IO\\\",\nwhich is the origin of typical Haskell memory catastrophes.\nBasically any case where you are\ntempted to use @mapM@, @replicateM@, @traverse@ or @sequence@\nwith Haskell lists, you would do better to use something like\n@Stream (Of a) m r@. The type signatures are a little fancier, but\nthe programs themselves are mostly the same or simpler. Thus,\nthe little demo program from\n<http://stackoverflow.com/questions/24068399/haskell-performance-of-iorefs this SO question>\n\n> main = mapM newIORef [1..10^8::Int] >>= mapM readIORef >>= mapM_ print\n\nquickly exhausts memory; this of course has nothing to do with @IORefs@\nand is cured by\n\n> import qualified Streaming.Prelude as S\n> main = S.print (S.mapM readIORef (S.mapM newIORef (S.each [1..10^8::Int])))\n\nwhich uses no more memory than @hello-world@, and is simpler anyway, since it\ndoesn't involve \\\"extracting a list from IO\\\". Almost\nevery use of list @mapM@, @replicateM@, @traverse@ and @sequence@ produces\nthis problem on a smaller scale. People get used to it, as if it were\ncharacteristic of Haskell programs to use a lot of memory, when\n\\\"extracting a list or sequence from IO\\\" is just bad practice pure and simple.\nList @mapM@, @replicateM@, @traverse@ and @sequence@ make sense under certain\nconditions. Similarly, @unsafePerformIO@ makes sense under certain conditions.\n\nThe @Streaming@ module exports the general type,\n@Stream f m r@, which can be used to stream successive distinct\nsteps characterized by /any/\nfunctor @f@, though we are mostly interested in organizing computations\nof the form @Stream (Of a) m r@. The streaming-IO libraries have\nvarious devices for dealing\nwith effectful variants of @[a]@ or @([a],r)@. But it is only with\nthe general type @Stream f m r@, or some equivalent,\nthat one can envisage (for example) the connected streaming of their\nsorts of stream - as one makes lists of lists in the Haskell\n@Prelude@ and @Data.List@. One needs some such type if we are\nto express properly streaming equivalents of e.g.\n\n> group :: Ord a => [a] -> [[a]]\n> chunksOf :: Int -> [a] -> [[a]]\n> lines :: [Char] -> [[Char]] -- but similarly with bytestring, etc.\n\nto mention a few obviously desirable operations. (This is explained more elaborately in the <https://hackage.haskell.org/package/streaming#readme readme> below.) One could throw something\nlike @Stream@ on top of a prior stream concept: this is how @pipes@ and\n@pipes-group@ (which are very much our model here) use @FreeT@.\nBut once one grasps\nthe iterable stream concept needed to express those functions -\nhere given a somewhat optimized implementation as @Stream f m r@\n(following, as usual, models derived from the @pipes@ library) -\nthen one will also see that,\nwith it, one is /already/ in possession of a complete\nelementary streaming library - since one possesses @Stream ((,) a) m r@\nor equivalently @Stream (Of a) m r@. This\nis the type of a \\'generator\\' or \\'producer\\' or whatever\nyou call an effectful stream of items.\n/The present @Streaming.Prelude@ is thus the simplest streaming library that can replicate anything like the API of the @Prelude@ and @Data.List@/.\n\nThe emphasis of the library is on interoperation; for\nthe rest its advantages are: extreme simplicity, re-use of\nintuitions the user has gathered from mastery of @Prelude@ and\n@Data.List@, and a total and systematic rejection of type synonyms.\nThe two conceptual pre-requisites are some\ncomprehension of monad transformers and some familiarity\nwith \\'rank 2 types\\'. It is hoped that experimentation with this\nsimple material, starting with the ghci examples in @Streaming.Prelude@,\nwill give people who are new to these concepts some\nintuition about their importance. The most fundamental purpose of the\nlibrary is to express elementary streaming ideas without reliance on\na complex framework, but in a way that integrates transparently with\nthe rest of Haskell, using ideas - e.g. rank 2 types, which are here\nimplicit or explicit in most mapping - that the user can carry elsewhere,\nrather than binding her intelligence to a so-called streaming IO framework (as\nnecessary as that is for certain purposes.)\n\nSee the\n<https://hackage.haskell.org/package/streaming#readme readme>\nbelow for further explanation, including the examples linked there.\nElementary usage can be divined from the ghci examples in\n@Streaming.Prelude@ and perhaps from this rough beginning of a\n<https://github.com/michaelt/streaming-tutorial/blob/master/tutorial.md tutorial>.\nNote also the\n<https://hackage.haskell.org/package/streaming-bytestring streaming bytestring>\nand\n<https://hackage.haskell.org/package/streaming-utils streaming utils>\npackages. Questions about usage can be put\nraised on StackOverflow with the tag @[haskell-streaming]@,\nor as an issue on Github, or on the\n<https://groups.google.com/forum/#!forum/haskell-pipes pipes list>\n(the package understands itself as part of the pipes \\'ecosystem\\'.)\n\nThe simplest form of interoperation with\n<http://hackage.haskell.org/package/pipes pipes>\nis accomplished with this isomorphism:\n\n> Pipes.unfoldr Streaming.next        :: Stream (Of a) m r   -> Producer a m r\n> Streaming.unfoldr Pipes.next        :: Producer a m r      -> Stream (Of a) m r\n\nInteroperation with\n<http://hackage.haskell.org/package/io-streams io-streams>\nis thus:\n\n> Streaming.reread IOStreams.read     :: InputStream a       -> Stream (Of a) IO ()\n> IOStreams.unfoldM Streaming.uncons  :: Stream (Of a) IO () -> IO (InputStream a)\n\nWith\n<http://hackage.haskell.org/package/conduit conduit>\none might use, e.g.:\n\n> Conduit.unfoldM Streaming.uncons                :: Stream (Of a) m ()  -> Source m a\n> Streaming.mapM_ Conduit.yield . hoist lift      :: Stream (Of o) m r -> ConduitM i o m r\n> (\$\$ Conduit.mapM_ Streaming.yield) . hoist lift :: Source m a -> Stream (Of a) m ()\n\nThese conversions should never be more expensive than a single @>->@ or @=\$=@.\nThe simplest interoperation with regular Haskell lists is provided by, say\n\n> Streaming.each                                  :: [a] -> Stream (Of a) m ()\n> Streaming.toList_                              :: Stream (Of a) m r -> m [a]\n\nThe latter of course accumulates the whole list in memory, and is mostly what we are trying\nto avoid. Every use of @Prelude.mapM f@ should be reconceived as using the\ncomposition @Streaming.toList_ . Streaming.mapM f . Streaming.each@ with a view to\nconsidering whether the accumulation required by @Streaming.toList_@ is really necessary.\n\nHere are the results of some\n<https://gist.github.com/michaelt/f19bef01423b17f29ffd microbenchmarks>\nbased on the\n<https://github.com/ekmett/machines/blob/master/benchmarks/Benchmarks.hs benchmarks>\nincluded in the machines package:\n\n<<http://i.imgur.com/sSG5MvH.png>>\n\nBecause these are microbenchmarks for individual functions,\nthey represent a sort of \\\"worst case\\\"; many other factors can influence\nthe speed of a complex program.\n";
      buildType = "Simple";
    };
    components = {
      "library" = {
        depends  = [
          (hsPkgs.base)
          (hsPkgs.mtl)
          (hsPkgs.mmorph)
          (hsPkgs.transformers)
          (hsPkgs.transformers-base)
          (hsPkgs.resourcet)
          (hsPkgs.exceptions)
          (hsPkgs.monad-control)
          (hsPkgs.time)
          (hsPkgs.ghc-prim)
        ];
      };
    };
  }