{ system
, compiler
, flags
, pkgs
, hsPkgs
, pkgconfPkgs
, ... }:
  {
    flags = {};
    package = {
      specVersion = "1.24";
      identifier = {
        name = "symantic";
        version = "6.0.0.20170623";
      };
      license = "GPL-3.0-only";
      copyright = "";
      maintainer = "Julien Moutinho <julm+symantic@autogeree.net>";
      author = "Julien Moutinho <julm+symantic@autogeree.net>";
      homepage = "";
      url = "";
      synopsis = "Library for Typed Tagless-Final Higher-Order Composable DSL";
      description = "__Description__\n\nThis is an experimental library for composing, parsing, typing, compiling, transforming and interpreting\na custom DSL (Domain-Specific Language) expressing\na subset of GHC's Haskell type system:\n\n* /first class functions/ (aka. /lambdas/),\n* chosen /monomorphic types/ (like 'Bool' or 'Maybe'),\n* chosen /rank-1 polymorphic types/ (like @(@'Maybe'@ a)@),\n* chosen /type class instances/,\n* chosen /type family instances/,\n* and chosen /type constraints/;\n\nwhere \"chosen X\" means declared in Haskell\nand selected when composing the DSL.\n\nIn particular, this library is currently not able to:\n\n* do /type inferencing/ for the argument of /lambdas/\n(they must all be explicitely annotated, aka. /Church-style/),\n* do /pattern matching/ (aka. /case/) (but /Church-encoding/ functions are often enough),\n* do /rank-N polymorphic types/ (aka. /non-prenex forall/, like @(forall s. ST s a) -> a@).\n\nAnd by itself, the DSL is only able to define new terms to be interpreted,\nno new types, or other type-level structures.\n\n__Warning__\n\nPlease be aware that despite its using of powerful ideas from clever people,\nthis remains a FUND-LESS SINGLE-PERSON EXPERIMENTAL LIBRARY.\nMeaning that it IS NOT heavily tested and documented,\nDOES NOT have a strong commitment to preserving backward compatibility,\nMAY FAIL to comply with the <http://www.haskell.org/haskellwiki/Package_versioning_policy PVP>,\nand CAN die without notice.\nYou've been warned.\n\n__Use cases__\n\nThe main goal of this library is to enable the runtime interpretation of terms,\ntype-checked according to some types defined at composing-time (ie. GHC's compile-time).\n\nUsing a DSL enables to limit expressiveness in order to ease analysis.\nHere the idea is that the more complex logic shall remain written in Haskell,\nand then this library used to project an interface into a DSL\n(using GHC's Haskell as a FFI (Foreign Function Interface)).\nThis in order to give runtime users the flexibility\nto write programs not requiring a full-blown Haskell compiler,\nyet enabling enough flexibility to let them express complex needs\nwith a reasonably advanced type-safe way\nand a controlled environment of primitives.\n\nTypical use cases:\n\n* Enabling runtime users to enter some Haskell-like expressions\n(maybe with a more convenient syntax wrt. the domain problem)\nwithout using at runtime all the heavy machinery and ecosystem of GHC\n(eg. by using <https://hackage.haskell.org/package/hint hint>),\nbut still leaning on primitive functions coded in GHC's Haskell.\n* Limiting those expressions to be built from well-controlled expressions only.\n* Run some analyzes/optimizations on those well-controlled expressions.\n\n__Usage__\n\nPlease pick in <https://hackage.haskell.org/package/symantic-lib symantic-lib>\na few specific @Lib/*.hs@ files near what you want to do\nand the corresponding @Lib\\/*/Test.hs@ file,\nif any in the <git://git.autogeree.net/symantic Git repository>,\nto learn by examples how to use this library.\n\nThose @Lib\\/*/Test.hs@ files use <https://hackage.haskell.org/package/megaparsec megaparsec> as parser\n(see @Grammar/Megaparsec.hs@) and a default grammar somehow sticking to Haskell's,\nbut staying context-free (so in particular: insensitive to the indentation),\nand supporting prefix and postfix operators.\nThis grammar — itself written as a symantic embedded DSL\nwith <https://hackage.haskell.org/package/symantic-grammar symantic-grammar> —\ncan be reused to build other ones, is not bound to a specific parser,\nand can produce its own EBNF rendition.\n\n__Acknowledgements__\n\nThis library would probably be much worse than it is\nwithout the following seminal works:\n\n* <http://okmij.org/ftp/tagless-final/ Finally Tagless> by Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan.\n* <http://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf Dependent Types in Haskell> by Richard A. Eisenberg.\n\n__Main ideas__\n\n* __Symantic DSL__.\nTerms are encoded in the <http://okmij.org/ftp/tagless-final/ Tagless-Final> way (aka. the /symantic/ way)\nwhich leverages the /type class/ system of Haskell — instead of using /data types/ — to form an embedded DSL.\nMore specifically, a /class/ encodes the /syntax/ of terms (eg. 'Sym_Bool')\nand its /class instances/ on a dedicated type encodes their /semantics/\n(eg. @(Sym_Bool Eval)@ interprets a term as a value of its type\nin the host language ('Bool' in Haskell here),\nor @(Sym_Bool View)@ interprets a term as a textual rendition, etc.).\nDSL are then composed/extended by selecting those symantic /classes/\n(and in an embedded DSL those could even be automatically inferred,\nwhen @NoMonomorphismRestriction@ is on).\nOtherwise, when using symantics for a non-embedded DSL\n— the whole point of this library — the /classes/ composing the DSL\nare selected manually at GHC's compile-time,\nthrough the /type-level list/ @ss@ given to 'readTerm'.\nMoreover, those symantic @term@s are parameterized by the type of the value they encode,\nin order to get the same type safety as with plain Haskell values.\nHence the symantic /classes/ have the higher kind: @((* -> *) -> Constraint)@\ninstead of just @(* -> Constraint)@.\nAmongst those symantics, 'Sym_Lambda' introduces /lambda abstractions/ by an higher-order approach,\nmeaning that they directly reuse GHC's internal machinery\nto abstract or instantiate variables,\nwhich I think is by far the most efficient and simplest way of doing it\n(no (generalized or not) DeBruijn encoding\nlike in <https://hackage.haskell.org/package/bound bound>'s @Monad@s).\n* __Singleton for any type__.\nTo typecheck terms using a @(@'Type'@ src vs t)@ which acts as a /singleton type/\nfor any Haskell /type index/ @t@ of any kind,\nwhich is made possible with the dependant Haskell extensions:\nespecially @TypeFamilies@, @GADTs@ and @TypeInType@.\n* __Type constants using 'Typeable'__.\n/Type constant/ could be introduced by indexing them amongst a /type-level list/,\nbut since they are /monomorphic types/, using 'Typeable' simplifies\nthe machinery, and is likely more space/time efficient, including at GHC-compile-time.\n* __Type variables using a type-level list__.\nHandling /type variables/ is done by indexing them amongst a @vs@ /type-level list/,\nwhere each /type variable/ is wrapped inside a @Proxy@ to handle different kinds.\nPerforming a substitution (in 'substVar') preserves the /type index/ @t@,\nwhich is key for preserving any associated 'Term'.\nUnifying /type variables/ is done with 'unsafeCoerce' (in 'unifyType'),\nwhich I think is necessary and likely safe.\n\n__Main extensions__\n\n* @AllowAmbiguousTypes@ for avoiding a lot of uses of 'Proxy'.\n* @ConstraintKinds@ for /type lists/ to contain 'Constraint's,\nor reifying any 'Constraint' as an explicit dictionary 'Dict',\nor defining /type synonym/ of /type classes/,\nor merging /type constraints/.\n* @DataKinds@ for type-level data structures (eg. /type-level lists/).\n* @DefaultSignatures@ for providing identity transformations of terms,\nand thus avoid boilerplate code when a transformation\ndoes not need to alter all semantics.\nAlmost as explained in <https://ro-che.info/articles/2016-02-03-finally-tagless-boilerplate Reducing boilerplate in finally tagless style>.\n* @GADTs@ for knowing types by pattern-matching terms,\nor building terms by using type classes.\n* @PolyKinds@ for avoiding a lot of uses of 'Proxy'.\n* @Rank2Types@ or @ExistentialQuantification@ for parsing @GADT@s.\n* @TypeApplications@ for having a more concise syntax\nto build 'Type' (eg. 'tyConst'@ @\\@Bool).\n* @TypeFamilies@ for type-level programming.\n* @TypeInType@ (introduced in GHC 8.0.1)\nfor 'Type' to also bind a kind equality for the type @t@ it encodes.\nWhich makes the /type application/ ('TyApp')\ngive us an /arrow kind/ for the Haskell /type constructor/\nit applies an Haskell type to, releaving me from tricky workarounds.\n* @UndecidableInstances@ for type-level programming that may never terminate.\n\n__Bugs__\n\nThere are some of them hidding in there,\nand the whole thing is far from being perfect…\nYour comments, problem reports, or questions, are welcome!\nYou have my email address, so… just send me some emails :]\n\n__To do__\n\n* Study to which point /type inferencing/ is doable,\nnow that 'Type' is powerful enough to contain 'TyVar's.\n* Study to which point error messages can be improved,\nnow that there is a 'Source' carried through all 'Kind's or 'Type's,\nit should enable some nice reports.\nStill, a lot of work and testing remain to be done,\nand likely some ideas to find too…\n* Add more terms in <https://hackage.haskell.org/package/symantic-lib symantic-lib>.\n* Add more transformations.\n* Study how to integrate types into the module system.\n* Study where to put @INLINE@, @INLINEABLE@ or @SPECIALIZE@ pragmas.\n* Study how to support /rank-N polymorphic types/,\nspecial cases can likely use the /boxed polymorphism/ workaround,\nbut even if GHC were supporting /impredicative types/,\nI'm currently clueless about how to do this.";
      buildType = "Simple";
    };
    components = {
      "library" = {
        depends  = [
          (hsPkgs.base)
          (hsPkgs.containers)
          (hsPkgs.ghc-prim)
          (hsPkgs.mono-traversable)
          (hsPkgs.symantic-grammar)
          (hsPkgs.symantic-document)
          (hsPkgs.transformers)
          (hsPkgs.text)
        ];
      };
    };
  }